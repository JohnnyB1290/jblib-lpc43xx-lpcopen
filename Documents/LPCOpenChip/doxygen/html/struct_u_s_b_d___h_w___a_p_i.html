<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LPCOpenChip: USBD_HW_API Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LPCOpenChip
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_u_s_b_d___h_w___a_p_i.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">USBD_HW_API Struct Reference<div class="ingroups"><a class="el" href="group___u_s_b_d___h_w.html">USB Device Controller Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Hardware API functions structure.This module exposes functions which interact directly with USB device controller hardware.  
 <a href="struct_u_s_b_d___h_w___a_p_i.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="usbd__hw_8h_source.html">usbd_hw.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a6b61fb5a82eab9e8f89aa906877f5dff"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a6b61fb5a82eab9e8f89aa906877f5dff">GetMemSize</a> )(<a class="el" href="group___u_s_b_d___core.html#gaa6e8171941c1ae63afed95974e0f18e3">USBD_API_INIT_PARAM_T</a> *param)</td></tr>
<tr class="separator:a6b61fb5a82eab9e8f89aa906877f5dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadada6a77e56ade8bf4493fbf57024f"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#aaadada6a77e56ade8bf4493fbf57024f">Init</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> *phUsb, <a class="el" href="group___u_s_b_d___core.html#gabdc617d119eac0555f91bea957c41ecc">USB_CORE_DESCS_T</a> *pDesc, <a class="el" href="group___u_s_b_d___core.html#gaa6e8171941c1ae63afed95974e0f18e3">USBD_API_INIT_PARAM_T</a> *param)</td></tr>
<tr class="separator:aaadada6a77e56ade8bf4493fbf57024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d202b9067c3b68520b61f6f4a573c5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a88d202b9067c3b68520b61f6f4a573c5">Connect</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t con)</td></tr>
<tr class="separator:a88d202b9067c3b68520b61f6f4a573c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d933cfcff6f27e147115ddac3bb701"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a30d933cfcff6f27e147115ddac3bb701">ISR</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="separator:a30d933cfcff6f27e147115ddac3bb701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1017adf322915aec669dd75160d2f574"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a1017adf322915aec669dd75160d2f574">Reset</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="separator:a1017adf322915aec669dd75160d2f574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e056a046ec1b63947e519df4bdef7da"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a0e056a046ec1b63947e519df4bdef7da">ForceFullSpeed</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t cfg)</td></tr>
<tr class="separator:a0e056a046ec1b63947e519df4bdef7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf24e047f28b790b004d8bb402e538"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#acaaf24e047f28b790b004d8bb402e538">WakeUpCfg</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t cfg)</td></tr>
<tr class="separator:acaaf24e047f28b790b004d8bb402e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f78aa831299766c30bae58ec0a76e89"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a6f78aa831299766c30bae58ec0a76e89">SetAddress</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t adr)</td></tr>
<tr class="separator:a6f78aa831299766c30bae58ec0a76e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8579aa72ae8936d7c7cca5100556b7ea"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a8579aa72ae8936d7c7cca5100556b7ea">Configure</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t cfg)</td></tr>
<tr class="separator:a8579aa72ae8936d7c7cca5100556b7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcff8284e52bdc4236ad198a49373cca"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#adcff8284e52bdc4236ad198a49373cca">ConfigEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, <a class="el" href="group___u_s_b_d___core.html#ga652b2871268bd903653cbff0f3448a6e">USB_ENDPOINT_DESCRIPTOR</a> *pEPD)</td></tr>
<tr class="separator:adcff8284e52bdc4236ad198a49373cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9504b9ea12782eb30e1a757463e3ed"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#aaa9504b9ea12782eb30e1a757463e3ed">DirCtrlEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t dir)</td></tr>
<tr class="separator:aaa9504b9ea12782eb30e1a757463e3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e4e0e555e545efb59d6e668a65a843"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a67e4e0e555e545efb59d6e668a65a843">EnableEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="separator:a67e4e0e555e545efb59d6e668a65a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac768ea3adcc8705cb644dfec9276af52"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#ac768ea3adcc8705cb644dfec9276af52">DisableEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="separator:ac768ea3adcc8705cb644dfec9276af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a3665c81a6658d5157d5072c2e987c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a76a3665c81a6658d5157d5072c2e987c">ResetEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="separator:a76a3665c81a6658d5157d5072c2e987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad087a4154897e11e60d6c716abf2f0e1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#ad087a4154897e11e60d6c716abf2f0e1">SetStallEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="separator:ad087a4154897e11e60d6c716abf2f0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a403e26d1d39309f94fb5a389b8c1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a222a403e26d1d39309f94fb5a389b8c1">ClrStallEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="separator:a222a403e26d1d39309f94fb5a389b8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97c508a4cf05225f63a8463e5f7de5"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#aaf97c508a4cf05225f63a8463e5f7de5">SetTestMode</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint8_t mode)</td></tr>
<tr class="separator:aaf97c508a4cf05225f63a8463e5f7de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8c1d7c842de4aaa5782679876bc46d"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a5a8c1d7c842de4aaa5782679876bc46d">ReadEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint8_t *pData)</td></tr>
<tr class="separator:a5a8c1d7c842de4aaa5782679876bc46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24184a309808f4503d9d4f28d0f37269"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a24184a309808f4503d9d4f28d0f37269">ReadReqEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len)</td></tr>
<tr class="separator:a24184a309808f4503d9d4f28d0f37269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9721db94e29e3993ad35d10e3912052d"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a9721db94e29e3993ad35d10e3912052d">ReadSetupPkt</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint32_t *pData)</td></tr>
<tr class="separator:a9721db94e29e3993ad35d10e3912052d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae241cd5aa91e5dedeb907d6407e11e64"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#ae241cd5aa91e5dedeb907d6407e11e64">WriteEP</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt)</td></tr>
<tr class="separator:ae241cd5aa91e5dedeb907d6407e11e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17d29a27c1697b43925b14b07aeedb1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#ad17d29a27c1697b43925b14b07aeedb1">WakeUp</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="separator:ad17d29a27c1697b43925b14b07aeedb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230e129cc95afdf2bd506fa98b58a984"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#a230e129cc95afdf2bd506fa98b58a984">EnableEvent</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable)</td></tr>
<tr class="separator:a230e129cc95afdf2bd506fa98b58a984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hardware API functions structure.</p>
<p>This module exposes functions which interact directly with USB device controller hardware. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a222a403e26d1d39309f94fb5a389b8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a403e26d1d39309f94fb5a389b8c1">&#9670;&nbsp;</a></span>ClrStallEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClrStallEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to clear STALL state for the requested endpoint.</p>
<p>This function clears STALL state for the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="adcff8284e52bdc4236ad198a49373cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcff8284e52bdc4236ad198a49373cca">&#9670;&nbsp;</a></span>ConfigEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConfigEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to configure USB Endpoint according to descriptor.</p>
<p>This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received</p>
<p>by the stack from USB host. All the endpoints associated with the selected configuration are configured. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEPD</td><td>Endpoint descriptor structure defined in USB 2.0 specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a8579aa72ae8936d7c7cca5100556b7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8579aa72ae8936d7c7cca5100556b7ea">&#9670;&nbsp;</a></span>Configure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Configure</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to configure device controller hardware with selected configuration.</p>
<p>This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received</p>
<p>by the stack from USB host. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Configuration index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a88d202b9067c3b68520b61f6f4a573c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d202b9067c3b68520b61f6f4a573c5">&#9670;&nbsp;</a></span>Connect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Connect</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to make USB device visible/invisible on the USB bus.</p>
<p>This function is called after the USB initialization. This function uses the soft connect feature to make the device visible on the USB bus. This function is called only after the application is ready to handle the USB data. The enumeration process is started by the host after the device detection. The driver handles the enumeration process according to the USB descriptors passed in the USB initialization function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">con</td><td>States whether to connect (1) or to disconnect (0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="aaa9504b9ea12782eb30e1a757463e3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9504b9ea12782eb30e1a757463e3ed">&#9670;&nbsp;</a></span>DirCtrlEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DirCtrlEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to set direction for USB control endpoint EP0.</p>
<p>This function is called automatically by the stack on need basis. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>When 1 - Set EP0 in IN transfer mode 0 - Set EP0 in OUT transfer mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ac768ea3adcc8705cb644dfec9276af52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac768ea3adcc8705cb644dfec9276af52">&#9670;&nbsp;</a></span>DisableEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DisableEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to disable selected USB endpoint.</p>
<p>This function disables interrupts on selected endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a67e4e0e555e545efb59d6e668a65a843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e4e0e555e545efb59d6e668a65a843">&#9670;&nbsp;</a></span>EnableEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnableEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to enable selected USB endpoint.</p>
<p>This function enables interrupts on selected endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a230e129cc95afdf2bd506fa98b58a984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230e129cc95afdf2bd506fa98b58a984">&#9670;&nbsp;</a></span>EnableEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnableEvent</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to enable/disable selected USB event.</p>
<p>This function enables interrupts on selected endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number corresponding to the event. ie. An EP1_IN is represented by 0x81 number. For device events set this param to 0x0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_type</td><td>Type of endpoint event. See <a class="el" href="group___u_s_b_d___h_w.html#ga61dde6aa35d2912927ef1b185eedaa13">USBD_EVENT_T</a> for more details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>1 - enable event, 0 - disable event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK(0)</td><td>- On success </td></tr>
    <tr><td class="paramname">ERR_USBD_INVALID_REQ(0x00040001)</td><td>- Invalid event type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e056a046ec1b63947e519df4bdef7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e056a046ec1b63947e519df4bdef7da">&#9670;&nbsp;</a></span>ForceFullSpeed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForceFullSpeed</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to force high speed USB device to operate in full speed mode.</p>
<p>This function is useful for testing the behavior of current device when connected to a full speed only hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>When 1 - set force full-speed or 0 - clear force full-speed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a6b61fb5a82eab9e8f89aa906877f5dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b61fb5a82eab9e8f89aa906877f5dff">&#9670;&nbsp;</a></span>GetMemSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GetMemSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to determine the memory required by the USB device stack's DCD and core layers.</p>
<p>This function is called by application layer before calling pUsbApi-&gt;hw-&gt;<a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#aaadada6a77e56ade8bf4493fbf57024f">Init()</a>, to allocate memory used by DCD and core layers. The application should allocate the memory which is accessible by USB controller/DMA controller. </p><dl class="section note"><dt>Note</dt><dd>Some memory areas are not accessible by all bus masters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Structure containing USB device stack initialization parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the required memory size in bytes. </dd></dl>

</div>
</div>
<a id="aaadada6a77e56ade8bf4493fbf57024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadada6a77e56ade8bf4493fbf57024f">&#9670;&nbsp;</a></span>Init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t Init</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to initialize USB device stack's DCD and core layers.</p>
<p>This function is called by application layer to initialize USB hardware and core layers. On successful initialization the function returns a handle to USB device stack which should be passed to the rest of the functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">phUsb</td><td>Pointer to the USB device stack handle of type USBD_HANDLE_T. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDesc</td><td>Structure containing pointers to various descriptor arrays needed by the stack. These descriptors are reported to USB host as part of enumerations process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Structure containing USB device stack initialization parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK(0)</td><td>On success </td></tr>
    <tr><td class="paramname">ERR_USBD_BAD_MEM_BUF(0x0004000b)</td><td>When insufficient memory buffer is passed or memory is not aligned on 2048 boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30d933cfcff6f27e147115ddac3bb701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d933cfcff6f27e147115ddac3bb701">&#9670;&nbsp;</a></span>ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to USB device controller interrupt events.</p>
<p>When the user application is active the interrupt handlers are mapped in the user flash space. The user application must provide an interrupt handler for the USB interrupt and call this function in the interrupt handler routine. The driver interrupt handler takes appropriate action according to the data received on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a5a8c1d7c842de4aaa5782679876bc46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8c1d7c842de4aaa5782679876bc46d">&#9670;&nbsp;</a></span>ReadEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ReadEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read data received on the requested endpoint.</p>
<p>This function is called by USB stack and the application layer to read the data received on the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pData</td><td>Pointer to the data buffer where data is to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes copied to the buffer. </dd></dl>

</div>
</div>
<a id="a24184a309808f4503d9d4f28d0f37269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24184a309808f4503d9d4f28d0f37269">&#9670;&nbsp;</a></span>ReadReqEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ReadReqEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to queue read request on the specified endpoint.</p>
<p>This function is called by USB stack and the application layer to queue a read request on the specified endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pData</td><td>Pointer to the data buffer where data is to be copied. This buffer address should be accessible by USB DMA master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the buffer passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the requested buffer. </dd></dl>

</div>
</div>
<a id="a9721db94e29e3993ad35d10e3912052d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9721db94e29e3993ad35d10e3912052d">&#9670;&nbsp;</a></span>ReadSetupPkt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ReadSetupPkt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read setup packet data received on the requested endpoint.</p>
<p>This function is called by USB stack and the application layer to read setup packet data received on the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP0_IN is represented by 0x80 number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pData</td><td>Pointer to the data buffer where data is to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes copied to the buffer. </dd></dl>

</div>
</div>
<a id="a1017adf322915aec669dd75160d2f574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1017adf322915aec669dd75160d2f574">&#9670;&nbsp;</a></span>Reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to Reset USB device stack and hardware controller.</p>
<p>Reset USB device stack and hardware controller. Disables all endpoints except EP0. Clears all pending interrupts and resets endpoint transfer queues. This function is called internally by pUsbApi-&gt;hw-&gt;init() and from reset event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a76a3665c81a6658d5157d5072c2e987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a3665c81a6658d5157d5072c2e987c">&#9670;&nbsp;</a></span>ResetEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResetEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to reset selected USB endpoint.</p>
<p>This function flushes the endpoint buffers and resets data toggle logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a6f78aa831299766c30bae58ec0a76e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f78aa831299766c30bae58ec0a76e89">&#9670;&nbsp;</a></span>SetAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAddress</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to set USB address assigned by host in device controller hardware.</p>
<p>This function is called automatically when USB_REQUEST_SET_ADDRESS request is received</p>
<p>by the stack from USB host. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adr</td><td>USB bus Address to which the device controller should respond. Usually assigned by the USB host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ad087a4154897e11e60d6c716abf2f0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad087a4154897e11e60d6c716abf2f0e1">&#9670;&nbsp;</a></span>SetStallEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetStallEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to STALL selected USB endpoint.</p>
<p>Generates STALL signaling for requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="aaf97c508a4cf05225f63a8463e5f7de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97c508a4cf05225f63a8463e5f7de5">&#9670;&nbsp;</a></span>SetTestMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t SetTestMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to set high speed USB device controller in requested test mode.</p>
<p>USB-IF requires the high speed device to be put in various test modes for electrical testing. This USB device stack calls this function whenever it receives USB_REQUEST_CLEAR_FEATURE request for USB_FEATURE_TEST_MODE. Users can put the device in test mode by directly calling this function. Returns ERR_USBD_INVALID_REQ when device controller is full-speed only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Test mode defined in USB 2.0 electrical testing specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK(0)</td><td>- On success </td></tr>
    <tr><td class="paramname">ERR_USBD_INVALID_REQ(0x00040001)</td><td>- Invalid test mode or Device controller is full-speed only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad17d29a27c1697b43925b14b07aeedb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17d29a27c1697b43925b14b07aeedb1">&#9670;&nbsp;</a></span>WakeUp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WakeUp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to generate resume signaling on bus for remote host wakeup.</p>
<p>This function is called by application layer to remotely wakeup host controller when system is in suspend state. Application should indicate this remote wakeup capability by setting USB_CONFIG_REMOTE_WAKEUP in bmAttributes of Configuration Descriptor. Also this routine will generate resume signalling only if host enables USB_FEATURE_REMOTE_WAKEUP by sending SET_FEATURE request before suspending the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="acaaf24e047f28b790b004d8bb402e538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaf24e047f28b790b004d8bb402e538">&#9670;&nbsp;</a></span>WakeUpCfg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WakeUpCfg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to configure USB device controller to wake-up host on remote events.</p>
<p>This function is called by application layer to configure the USB device controller to wakeup on remote events. It is recommended to call this function from users's USB_WakeUpCfg() callback routine registered with stack. </p><dl class="section note"><dt>Note</dt><dd>User's USB_WakeUpCfg() is registered with stack by setting the USB_WakeUpCfg member of USBD_API_INIT_PARAM_T structure before calling pUsbApi-&gt;hw-&gt;<a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#aaadada6a77e56ade8bf4493fbf57024f">Init()</a> routine. Certain USB device controllers needed to keep some clocks always on to generate resume signaling through pUsbApi-&gt;hw-&gt;<a class="el" href="struct_u_s_b_d___h_w___a_p_i.html#ad17d29a27c1697b43925b14b07aeedb1">WakeUp()</a>. This hook is provided to support such controllers. In most controllers cases this is an empty routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>When 1 - Configure controller to wake on remote events or 0 - Configure controller not to wake on remote events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ae241cd5aa91e5dedeb907d6407e11e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae241cd5aa91e5dedeb907d6407e11e64">&#9670;&nbsp;</a></span>WriteEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t WriteEP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to write data to be sent on the requested endpoint.</p>
<p>This function is called by USB stack and the application layer to send data on the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Pointer to the data buffer from where data is to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes written. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>H:/JB_Lib/LPC43XX/LPC43XX_Open_chip/include/usbd_rom/<a class="el" href="usbd__hw_8h_source.html">usbd_hw.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_u_s_b_d___h_w___a_p_i.html">USBD_HW_API</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
