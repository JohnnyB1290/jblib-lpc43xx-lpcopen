<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LPCOpenChip: USBD_CDC_INIT_PARAM Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LPCOpenChip
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">USBD_CDC_INIT_PARAM Struct Reference<div class="ingroups"><a class="el" href="group___u_s_b_d___c_d_c.html">Communication Device Class (CDC) Function Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Communication Device Class function driver initialization parameter data structure.  
 <a href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="usbd__cdcuser_8h_source.html">usbd_cdcuser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a5ba2f6f78705b63f0788f9b85f7f104c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a5ba2f6f78705b63f0788f9b85f7f104c">mem_base</a></td></tr>
<tr class="separator:a5ba2f6f78705b63f0788f9b85f7f104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6a3b0b58cbdacf4ce9a0c9b3d64794"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a3f6a3b0b58cbdacf4ce9a0c9b3d64794">mem_size</a></td></tr>
<tr class="separator:a3f6a3b0b58cbdacf4ce9a0c9b3d64794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2273cb833eb2d825c565fa61511bd935"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a2273cb833eb2d825c565fa61511bd935">cif_intf_desc</a></td></tr>
<tr class="separator:a2273cb833eb2d825c565fa61511bd935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3388a78b025fde02b2bc272bd2d6df40"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a3388a78b025fde02b2bc272bd2d6df40">dif_intf_desc</a></td></tr>
<tr class="separator:a3388a78b025fde02b2bc272bd2d6df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec17001faaeb90fc6e74d17545736b7b"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#aec17001faaeb90fc6e74d17545736b7b">CIC_GetRequest</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hHid, <a class="el" href="group___u_s_b_d___core.html#ga4a940f7627cc7e9f0bb693cc0fce8637">USB_SETUP_PACKET</a> *pSetup, uint8_t **pBuffer, uint16_t *length)</td></tr>
<tr class="separator:aec17001faaeb90fc6e74d17545736b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3696f42fc06ad966db507c9517a469e"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#aa3696f42fc06ad966db507c9517a469e">CIC_SetRequest</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCdc, <a class="el" href="group___u_s_b_d___core.html#ga4a940f7627cc7e9f0bb693cc0fce8637">USB_SETUP_PACKET</a> *pSetup, uint8_t **pBuffer, uint16_t length)</td></tr>
<tr class="separator:aa3696f42fc06ad966db507c9517a469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8ac4d9cd33ef0e1a003328d69e968d"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a0c8ac4d9cd33ef0e1a003328d69e968d">CDC_BulkIN_Hdlr</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td></tr>
<tr class="separator:a0c8ac4d9cd33ef0e1a003328d69e968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade1565aff8e84df85208c9eca9b1b79"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#aade1565aff8e84df85208c9eca9b1b79">CDC_BulkOUT_Hdlr</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td></tr>
<tr class="separator:aade1565aff8e84df85208c9eca9b1b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa574f429261b97f2bbecce87a812d3cd"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#aa574f429261b97f2bbecce87a812d3cd">SendEncpsCmd</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint8_t *buffer, uint16_t len)</td></tr>
<tr class="separator:aa574f429261b97f2bbecce87a812d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59a8e34de6912875959b270de09160b"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#aa59a8e34de6912875959b270de09160b">GetEncpsResp</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint8_t **buffer, uint16_t *len)</td></tr>
<tr class="separator:aa59a8e34de6912875959b270de09160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fe0abbe2efe20153d1b0b68df6e83e"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a73fe0abbe2efe20153d1b0b68df6e83e">SetCommFeature</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t feature, uint8_t *buffer, uint16_t len)</td></tr>
<tr class="separator:a73fe0abbe2efe20153d1b0b68df6e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49194845cd8fe069b674756634ddc8a3"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a49194845cd8fe069b674756634ddc8a3">GetCommFeature</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t feature, uint8_t **pBuffer, uint16_t *len)</td></tr>
<tr class="separator:a49194845cd8fe069b674756634ddc8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd5a058718f91c90cf03d1a3f7c4af"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a32dd5a058718f91c90cf03d1a3f7c4af">ClrCommFeature</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t feature)</td></tr>
<tr class="separator:a32dd5a058718f91c90cf03d1a3f7c4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2fd67743e8e14bb971a18f33e47942"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#acc2fd67743e8e14bb971a18f33e47942">SetCtrlLineState</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t state)</td></tr>
<tr class="separator:acc2fd67743e8e14bb971a18f33e47942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4077353995c7d9472e1301cb74794d96"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a4077353995c7d9472e1301cb74794d96">SendBreak</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t mstime)</td></tr>
<tr class="separator:a4077353995c7d9472e1301cb74794d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98ae6bcff41e900d886be37a92da7cc"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#ae98ae6bcff41e900d886be37a92da7cc">SetLineCode</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, <a class="el" href="struct___c_d_c___l_i_n_e___c_o_d_i_n_g.html">CDC_LINE_CODING</a> *line_coding)</td></tr>
<tr class="separator:ae98ae6bcff41e900d886be37a92da7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21069050d0af5f54a364f8aa58b74bf"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#ac21069050d0af5f54a364f8aa58b74bf">CDC_InterruptEP_Hdlr</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td></tr>
<tr class="separator:ac21069050d0af5f54a364f8aa58b74bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef468988e64f371ddba80bf41cb2ba5"><td class="memItemLeft" align="right" valign="top">ErrorCode_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html#a9ef468988e64f371ddba80bf41cb2ba5">CDC_Ep0_Hdlr</a> )(<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td></tr>
<tr class="separator:a9ef468988e64f371ddba80bf41cb2ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Communication Device Class function driver initialization parameter data structure. </p>
<p>This data structure is used to pass initialization parameters to the Communication Device Class function driver's init function. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a0c8ac4d9cd33ef0e1a003328d69e968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8ac4d9cd33ef0e1a003328d69e968d">&#9670;&nbsp;</a></span>CDC_BulkIN_Hdlr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* CDC_BulkIN_Hdlr) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communication Device Class specific BULK IN endpoint handler.</p>
<p>The application software should provide the BULK IN endpoint handler. Applications should transfer data depending on the communication protocol type set in descriptors. <br />
</p><dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data which will be passed when callback function is called by the stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Type of endpoint event. See <a class="el" href="group___u_s_b_d___h_w.html#ga61dde6aa35d2912927ef1b185eedaa13">USBD_EVENT_T</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aade1565aff8e84df85208c9eca9b1b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade1565aff8e84df85208c9eca9b1b79">&#9670;&nbsp;</a></span>CDC_BulkOUT_Hdlr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* CDC_BulkOUT_Hdlr) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communication Device Class specific BULK OUT endpoint handler.</p>
<p>The application software should provide the BULK OUT endpoint handler. Applications should transfer data depending on the communication protocol type set in descriptors. <br />
</p><dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data which will be passed when callback function is called by the stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Type of endpoint event. See <a class="el" href="group___u_s_b_d___h_w.html#ga61dde6aa35d2912927ef1b185eedaa13">USBD_EVENT_T</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef468988e64f371ddba80bf41cb2ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef468988e64f371ddba80bf41cb2ba5">&#9670;&nbsp;</a></span>CDC_Ep0_Hdlr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* CDC_Ep0_Hdlr) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optional user override-able function to replace the default CDC class handler.</p>
<p>The application software could override the default EP0 class handler with their own by providing the handler function address as this data member of the parameter structure. Application which like the default handler should set this data member to zero before calling the USBD_CDC_API::Init(). <br />
</p><dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data which will be passed when callback function is called by the stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Type of endpoint event. See <a class="el" href="group___u_s_b_d___h_w.html#ga61dde6aa35d2912927ef1b185eedaa13">USBD_EVENT_T</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21069050d0af5f54a364f8aa58b74bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21069050d0af5f54a364f8aa58b74bf">&#9670;&nbsp;</a></span>CDC_InterruptEP_Hdlr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* CDC_InterruptEP_Hdlr) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, void *data, uint32_t event)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optional Communication Device Class specific INTERRUPT IN endpoint handler.</p>
<p>The application software should provide the INT IN endpoint handler. Applications should transfer data depending on the communication protocol type set in descriptors. <br />
</p><dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data which will be passed when callback function is called by the stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Type of endpoint event. See <a class="el" href="group___u_s_b_d___h_w.html#ga61dde6aa35d2912927ef1b185eedaa13">USBD_EVENT_T</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec17001faaeb90fc6e74d17545736b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec17001faaeb90fc6e74d17545736b7b">&#9670;&nbsp;</a></span>CIC_GetRequest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* CIC_GetRequest) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hHid, <a class="el" href="group___u_s_b_d___core.html#ga4a940f7627cc7e9f0bb693cc0fce8637">USB_SETUP_PACKET</a> *pSetup, uint8_t **pBuffer, uint16_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communication Interface Class specific get request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends CIC management element get requests. </p><dl class="section note"><dt>Note</dt><dd>Applications implementing Abstract Control Model subclass can set this param to NULL. As the default driver parses ACM requests and calls the individual ACM call-back routines defined in this structure. For all other subclasses this routine should be provided by the application. <br />
The setup packet data (<em>pSetup</em>) is passed to the call-back so that application can extract the CIC request type and other associated data. By default the stack will assign <em>pBuffer</em> pointer to <em>EP0Buff</em> allocated at init. The application code can directly write data into this buffer as long as data is less than 64 byte. If more data has to be sent then application code should update <em>pBuffer</em> pointer and length accordingly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSetup</td><td>Pointer to setup packet received from host. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuffer</td><td>Pointer to a pointer of data buffer containing request data. Pointer-to-pointer is used to implement zero-copy buffers. See USBD_ZeroCopy for more details on zero-copy concept. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">length</td><td>Amount of data to be sent back to host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3696f42fc06ad966db507c9517a469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3696f42fc06ad966db507c9517a469e">&#9670;&nbsp;</a></span>CIC_SetRequest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* CIC_SetRequest) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCdc, <a class="el" href="group___u_s_b_d___core.html#ga4a940f7627cc7e9f0bb693cc0fce8637">USB_SETUP_PACKET</a> *pSetup, uint8_t **pBuffer, uint16_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communication Interface Class specific set request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a CIC management element requests. </p><dl class="section note"><dt>Note</dt><dd>Applications implementing Abstract Control Model subclass can set this param to NULL. As the default driver parses ACM requests and calls the individual ACM call-back routines defined in this structure. For all other subclasses this routine should be provided by the application. <br />
The setup packet data (<em>pSetup</em>) is passed to the call-back so that application can extract the CIC request type and other associated data. If a set request has data associated, then this call-back is called twice.<ol type="1">
<li>First when setup request is received, at this time application code could update <em>pBuffer</em> pointer to point to the intended destination. The length param is set to 0 so that application code knows this is first time. By default the stack will assign <em>pBuffer</em> pointer to <em>EP0Buff</em> allocated at init. Note, if data length is greater than 64 bytes and application code doesn't update <em>pBuffer</em> pointer the stack will send STALL condition to host.</li>
<li>Second when the data is received from the host. This time the length param is set with number of data bytes received.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSetup</td><td>Pointer to setup packet received from host. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuffer</td><td>Pointer to a pointer of data buffer containing request data. Pointer-to-pointer is used to implement zero-copy buffers. See USBD_ZeroCopy for more details on zero-copy concept. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Amount of data copied to destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2273cb833eb2d825c565fa61511bd935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2273cb833eb2d825c565fa61511bd935">&#9670;&nbsp;</a></span>cif_intf_desc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* cif_intf_desc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the control interface descriptor within the descriptor array (<em>high_speed_desc</em>) passed to Init() through <a class="el" href="group___u_s_b_d___core.html#gabdc617d119eac0555f91bea957c41ecc">USB_CORE_DESCS_T</a> structure. The stack assumes both HS and FS use same BULK endpoints. </p>

</div>
</div>
<a id="a32dd5a058718f91c90cf03d1a3f7c4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dd5a058718f91c90cf03d1a3f7c4af">&#9670;&nbsp;</a></span>ClrCommFeature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* ClrCommFeature) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t feature)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific CLEAR_COMM_FEATURE request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a CLEAR_COMM_FEATURE request. In the call-back the application should Clears the settings for a particular communication feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3388a78b025fde02b2bc272bd2d6df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3388a78b025fde02b2bc272bd2d6df40">&#9670;&nbsp;</a></span>dif_intf_desc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* dif_intf_desc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the data interface descriptor within the descriptor array (<em>high_speed_desc</em>) passed to Init() through <a class="el" href="group___u_s_b_d___core.html#gabdc617d119eac0555f91bea957c41ecc">USB_CORE_DESCS_T</a> structure. The stack assumes both HS and FS use same BULK endpoints. </p>

</div>
</div>
<a id="a49194845cd8fe069b674756634ddc8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49194845cd8fe069b674756634ddc8a3">&#9670;&nbsp;</a></span>GetCommFeature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* GetCommFeature) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t feature, uint8_t **pBuffer, uint16_t *len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific GET_COMM_FEATURE request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a GET_ENCAPSULATED_RESPONSE request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Pointer to a pointer of data buffer containing current settings for the communication feature. Pointer-to-pointer is used to implement zero-copy buffers. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Amount of data to be sent back to host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59a8e34de6912875959b270de09160b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59a8e34de6912875959b270de09160b">&#9670;&nbsp;</a></span>GetEncpsResp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* GetEncpsResp) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint8_t **buffer, uint16_t *len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific GET_ENCAPSULATED_RESPONSE request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a GET_ENCAPSULATED_RESPONSE request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Pointer to a pointer of data buffer containing response data. Pointer-to-pointer is used to implement zero-copy buffers. See USBD_ZeroCopy for more details on zero-copy concept. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Amount of data to be sent back to host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ba2f6f78705b63f0788f9b85f7f104c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba2f6f78705b63f0788f9b85f7f104c">&#9670;&nbsp;</a></span>mem_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mem_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Base memory location from where the stack can allocate data and buffers. </p><dl class="section note"><dt>Note</dt><dd>The memory address set in this field should be accessible by USB DMA controller. Also this value should be aligned on 4 byte boundary. </dd></dl>

</div>
</div>
<a id="a3f6a3b0b58cbdacf4ce9a0c9b3d64794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6a3b0b58cbdacf4ce9a0c9b3d64794">&#9670;&nbsp;</a></span>mem_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mem_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of memory buffer which stack can use. </p><dl class="section note"><dt>Note</dt><dd>The <em>mem_size</em> should be greater than the size returned by <a class="el" href="struct_u_s_b_d___c_d_c___a_p_i.html#a66487e730c2a8648196f23f475067cdf">USBD_CDC_API::GetMemSize()</a> routine. </dd></dl>

</div>
</div>
<a id="a4077353995c7d9472e1301cb74794d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4077353995c7d9472e1301cb74794d96">&#9670;&nbsp;</a></span>SendBreak</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* SendBreak) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t mstime)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific SEND_BREAK request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a SEND_BREAK request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mstime</td><td>Duration of Break signal in milliseconds. If mstime is FFFFh, then the application should send break until another SendBreak request is received with the wValue of 0000h. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa574f429261b97f2bbecce87a812d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa574f429261b97f2bbecce87a812d3cd">&#9670;&nbsp;</a></span>SendEncpsCmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* SendEncpsCmd) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint8_t *buffer, uint16_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific SEND_ENCAPSULATED_COMMAND request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a SEND_ENCAPSULATED_COMMAND set request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the command buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73fe0abbe2efe20153d1b0b68df6e83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fe0abbe2efe20153d1b0b68df6e83e">&#9670;&nbsp;</a></span>SetCommFeature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* SetCommFeature) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t feature, uint8_t *buffer, uint16_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific SET_COMM_FEATURE request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a SET_COMM_FEATURE set request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the settings buffer for the specified communication feature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the request buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2fd67743e8e14bb971a18f33e47942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2fd67743e8e14bb971a18f33e47942">&#9670;&nbsp;</a></span>SetCtrlLineState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* SetCtrlLineState) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, uint16_t state)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific SET_CONTROL_LINE_STATE request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a SET_CONTROL_LINE_STATE request. RS-232 signal used to tell the DCE device the DTE device is now present</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state value uses bitmap values defined in usbcdc11.pdf, section 6.2.14, Table 51. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae98ae6bcff41e900d886be37a92da7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98ae6bcff41e900d886be37a92da7cc">&#9670;&nbsp;</a></span>SetLineCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorCode_t(* SetLineCode) (<a class="el" href="group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hCDC, <a class="el" href="struct___c_d_c___l_i_n_e___c_o_d_i_n_g.html">CDC_LINE_CODING</a> *line_coding)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract control model(ACM) subclass specific SET_LINE_CODING request call-back function.</p>
<p>This function is provided by the application software. This function gets called when host sends a SET_LINE_CODING request. The application should configure the device per DTE rate, stop-bits, parity, and number-of-character bits settings provided in command buffer. See usbcdc11.pdf, section 6.2.13, table 50 for detail of the command buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCdc</td><td>Handle to CDC function driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_coding</td><td>Pointer to the CDC_LINE_CODING command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call back should returns ErrorCode_t type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success. </td></tr>
    <tr><td class="paramname">ERR_USBD_UNHANDLED</td><td>Event is not handled hence pass the event to next in line. </td></tr>
    <tr><td class="paramname">ERR_USBD_xxx</td><td>For other error conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>H:/JB_Lib/LPC43XX/LPC43XX_Open_chip/include/usbd_rom/<a class="el" href="usbd__cdcuser_8h_source.html">usbd_cdcuser.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_u_s_b_d___c_d_c___i_n_i_t___p_a_r_a_m.html">USBD_CDC_INIT_PARAM</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
